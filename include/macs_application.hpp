/// @file macs_application.hpp
/// @brief Интерфейс приложения.
/// @details Содержит классы для организации пользовательских приложений.
/// @copyright AstroSoft Ltd, 2016

#pragma once
 
#include "macs_common.hpp"

namespace macs {

/// @brief Базовый класс для приложения пользователя.
/// @details Реальный класс, представляющий приложение пользователя, должен быть производным от 
/// класса Application. Виртуальный метод Initialize() должен быть обязательно переопределен
/// в этом производном классе.
/// Стандартная схема использования класса приложения: в функции main создать экземпляр
/// класса приложения и выполнить метод Run().
class Application
{
public:
	virtual ~Application();

	/// @brief Запустить приложение.
	/// @details Выполняет инициализацию системы и приложения, а затем запускает планировщик.
	void Run();
	 
	/// @brief Интерфейс пользовательской функции обработки ошибок и предупреждений системы
	/// @details Функция вызываетя ядром системы для обработки исключительных ситуаций.
	/// Приложение оповещается о возникновении исключительной ситуации, после чего выполняется
	/// необходимое действие для обеспечения корректной реакции на исключительную ситуацию.
	/// @param reason [Причина](@ref macs::ALARM_REASON) возникновения исключительной ситуации
	/// @return [Действие](@ref macs::ALARM_ACTION), выполняемое системой после обработки
	/// исключительной ситуации в приложении
	virtual ALARM_ACTION OnAlarm(ALARM_REASON reason);

protected:
	/// @brief Конструктор приложения
	/// @param use_preemption Режим многозадачности (true - вытесняющая, false - кооперативная).
	Application(bool use_preemption = true);

private:
	CLS_COPY(Application)

	/// @brief Переопределяемый метод для инициализации приложения.
	/// @details Каждый класс приложения должен реализовывать данный метод, внутри которого производится 
	/// начальная инициализация приложения.  В том числе, там удобнее всего добавлять задачи для программы.
	/// Метод Initialize() всегда выполняется с привилегированным доступом, благодаря чему здесь возможна 
	/// инициализация системных регистров и т.п.
	virtual void Initialize() {}

public:
	static Application * m_app;
private:
	bool m_use_preemption;
};

inline Application & App() { return * Application::m_app; }

}  // namespace macs
using namespace macs;

#define MACS_ALARM(reason)	App().OnAlarm(reason)
